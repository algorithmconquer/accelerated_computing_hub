练习 - NumPy 到 CuPy - SVD 重建
让我们尝试另一个 NumPy 到 CuPy 的移植练习，这次使用之前的 SVD 重建代码。

TODO: 将此代码移植到 CuPy。以下是您需要做的事情：

将 import numpy as xp 更改为 import cupy as xp。
NumPy 数组使用 xp.asarray() 转换为 CuPy 数组。如果您忘记这样做，将看到类似 only supports cupy.ndarray 的错误。
CuPy 数组使用 xp.asnumpy() 转换回 NumPy 数组（用于 Matplotlib）。
首先，我们需要导入我们正在使用的计算机视觉和绑图库堆栈：

接下来，让我们下载一张 Bryce 的狗的图片：

然后我们以灰度模式读取该图像：

在这里我们可以看到该图像是 1600x1200 像素，每个像素是一个无符号 8 位值 (0-255)。让我们用 matplotlib 绑制它以验证它看起来是否正确：

是的，我们可以确认那是一只狗（而且是一只非常可爱的狗）。现在让我们开始进行一些线性代数运算！

NumPy 提供了一个 SVD 实现。通过选择 full_matrices=False，我们可以将奇异值矩阵 S 作为一个 1D 向量而不是 2D 对角矩阵获取。

由于图像不是方形的，并且我们没有选择 full_matrices，NumPy 返回的 U 是一个非方阵，S 是一个长度等于两个维度中较小者的 1D 向量，而 Vt 矩阵是一个方阵。

奇异值按降序返回，如果我们查看 S 的前 10 个元素就可以看到这一点：

事实上，如果我们查看奇异值的大小，会发现前几个对矩阵的贡献很大，然后非常快速地下降：

这表明我们可以用相对少量的项来获得原始图像相当好的近似。我们可以通过对 U、S 和 Vt 矩阵进行切片并重新相乘来重建图像矩阵。我们还需要将 S 转换回 2D 矩阵以进行乘法。注意，我们使用 @ 运算符来执行矩阵乘法，因为 * 执行的是逐元素乘法。

这仍然相当模糊，所以让我们查看包含更多项的图像：

附加题：在您将这个 for 循环移植到 CuPy 之后，请考虑计算和 I/O 的流程。这种模式是否存在问题？如何改进？

现在我们将打印上面使用的 n 值的压缩比。这是将缩减后数组的字节数相加，然后除以原始灰度图像数组的大小。看起来我们可以用这种技术获得显着的存储节省。

接下来，我们计算并显示 n = 10 时的重建图像与原始图像之间的差异，使用 cmap="coolwarm" 来显示差异。

现在您已经让 SVD 在 CuPy 上运行了，让我们来对它进行基准测试！为了更清楚起见，让我们用它们常用的缩写重新导入 NumPy 和 CuPy：

在对 GPU 代码进行基准测试时，我们必须非常小心。由于 GPU 编程本质上是异步的，因此确保我们测量的内容正确可能会有些棘手。

想象一下，您正在测量向某人寄送包裹需要多长时间，但您只计算了您去邮局投递所花费的时间，而不是他们收到它并向您发送感谢信所需的时间。

像 %timeit 这样的常见 Python 基准测试工具不支持 GPU，因此很容易使用它们进行不正确的测量。只有当我们知道我们正在进行基准测试的代码将执行适当的同步时，我们才能使用它们。最好使用类似 cupyx.profiler.benchmark 的工具。

首先，我们需要我们图像的一个 NumPy (CPU) 和一个 CuPy (GPU) 副本：

接下来，让我们对 CPU 和 GPU 执行进行基准测试：

根据您的硬件，CPU 和 GPU 可能速度接近，甚至 GPU 可能更慢！这是因为图像不够大，无法充分利用 GPU。我们可以使用 np.tile 平铺图像来模拟更大的图像。这将沿轴 0 和轴 1 复制图像：

现在我们可以再次进行基准测试（这将需要更长时间，因为矩阵大得多）：

TODO: 通过更改 np.tile 参数来尝试不同大小的图像。GPU 何时更快？