目录
数组数据的事实标准
ndarray
解析：结构与内存
数组创建与逻辑视图（视图 vs. 副本）
聚合与轴
广播："拉伸"规则
为何要向量化？速度优势
1. 数组数据的事实标准
NumPy 是 Python 中高性能计算 (HPC) 和机器学习 (ML) 的基础库。PyTorch、Pandas 和 Scikit-learn 等库都是基于或模仿 NumPy API 构建的。学习 NumPy 对于掌握数组编程范式至关重要。

NumPy 提供了 ndarray（N 维数组），这是一个强大、高性能且统一的容器，支持高效的内存管理、索引、切片，最重要的是支持向量化算术运算。

2. ndarray 解析：结构与内存
与标准 Python 列表不同，ndarray 是一个固定大小、结构化的连续内存块。其效率来源于以下四个关键的、不可变的属性：

数据 (Data)：指向存储元素的内存位置的指针。
数据类型 (dtype)：数据类型（例如 int32、float64），所有元素具有统一的类型。
形状 (Shape)：一个定义每个维度大小的元组（例如，$(100, 50)$ 表示 100 行 50 列）。
步幅 (Strides)：在内存中访问每个维度上的下一个元素所需移动的字节数——这是 NumPy 高效处理不同形状和视图的方式。
让我们通过创建一个大型数据集来探索这些属性。

快速文档

np.arange(start, stop, step)：返回半开区间 $[\text{start}, \text{stop})$ 内均匀分布的值。
arr.nbytes：数组元素所消耗的总字节数。
arr.ndim：数组的维度数量（整数）。
arr.size：数组中元素的总数（整数）。
arr.shape：数组维度的元组。
3. 数组创建与逻辑视图（视图 vs. 副本）
数组可以以多种方式逻辑地表示数据（例如，1D 信号、2D 图像、4D 视频批次），而与底层物理内存块无关。

一个关键的性能特性是，像转置或 reshape 这样的操作通常返回的是视图 (View) 而不是副本 (Copy)。视图仅更改元数据（shape 和 strides），而不复制物理数据，这使得这些操作几乎是瞬时完成的。

快速文档

np.linspace(start, stop, num)：返回在区间 $[\text{start}, \text{stop}]$ 内均匀分布的 num 个样本。
np.random.default_rng().random(size)：返回 $[0.0, 1.0)$ 范围内的随机浮点数。size 可以是元组。
arr.sort()：原地对数组排序（修改原始数据）。使用 np.sort(arr) 返回排序后的副本。
arr.reshape(new_shape)：返回具有新形状的视图。其中一个维度可以设为 -1，指示 NumPy 自动计算该维度的大小。
np.resize(arr, new_shape)：返回具有指定形状的新数组。如果新形状更大，则通过重复原始数组来填充新元素。
4. 聚合与轴
在执行聚合操作（如 sum、mean、max）时，您必须指定要沿其折叠（或归约）数组的轴 (Axis)。

轴 0 (Axis 0)：第一个维度（在 2D 数组中通常是行）。沿轴 0 聚合会为每一列产生一个结果。
轴 1 (Axis 1)：第二个维度（在 2D 数组中通常是列）。沿轴 1 聚合会为每一行产生一个结果。
快速文档

np.sum(a, axis=None)：对给定轴上的数组元素求和。
axis=0：折叠行（对垂直列求和）。
axis=1：折叠列（对水平行求和）。
5. 广播："拉伸"规则
广播是 NumPy 在不同形状的数组之间进行算术运算的机制。如果维度不匹配，NumPy 会尝试"拉伸"较小的数组以匹配较大的数组。

兼容性规则： 满足以下任一条件时，两个维度是兼容的：

它们相等，或者
其中一个为 1。
如果某个维度是 1，NumPy 会在逻辑上将该单个值沿该维度复制以匹配另一个数组的形状，而不会分配任何新内存。

快速文档

算术运算符 (/、*、+、-)：这些是按元素操作的。如果形状不同但兼容，则会发生广播。
np.allclose(a, b)：如果两个浮点数组在一定容差范围内按元素相等，则返回 True。这对于比较浮点数是必不可少的，而不应使用 ==。
6. 为何要向量化？速度优势
整个数组编程范式都依赖于向量化。

为什么使用复杂的形状和广播机制而不是简单的 Python for 循环？

NumPy 的数组函数是用高度优化的原生代码（C/C++、Fortran）实现的。对于一个巨大的 ndarray A，像 A + A**2 这样的运算，通常比使用显式 Python 循环执行等效的逐元素操作快 $\mathbf{100\times}$。

始终优先选择向量化的 NumPy 函数或运算符，而不是手动 Python 循环。