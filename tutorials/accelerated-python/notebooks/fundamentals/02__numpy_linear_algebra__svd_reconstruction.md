练习 - NumPy 线性代数 - SVD 重建
NumPy 的一个非常常见的用法是执行常见的线性代数算法。这些算法通常使用像 OpenBLAS 这样的库在 CPU 上高效实现。我们将在后续教程中了解如何将这些计算转移到 GPU 上。

在本教程中，我们将研究矩阵的奇异值分解 (SVD)。该矩阵将代表一幅灰度图像，我们将看到如何用前 N 个奇异值和奇异向量来近似该图像。例如，这可以作为图像压缩系统的一部分使用。

我们需要使用 OpenCV 来读取图像格式，并使用 matplotlib 来显示图像及其重建结果。

接下来，让我们下载一张 Bryce 的狗的图片：

然后我们以灰度模式读取该图像：

在这里我们可以看到该图像是 1600x1200 像素，每个像素是一个无符号 8 位值 (0-255)。让我们用 matplotlib 绘制它以验证它看起来是否正确：

是的，我们可以确认那是一只狗（而且是一只非常可爱的狗）。现在让我们开始进行一些线性代数运算！

NumPy 提供了一个 SVD 实现。通过选择 full_matrices=False，我们可以将奇异值矩阵 S 作为一个 1D 向量而不是 2D 对角矩阵获取。

由于图像不是方形的，并且我们没有选择 full_matrices，NumPy 返回的 U 是一个非方阵，S 是一个长度等于两个维度中较小者的 1D 向量，而 Vt 矩阵是一个方阵。

奇异值按降序返回，如果我们查看 S 的前 10 个元素就可以看到这一点：

事实上，如果我们查看奇异值的大小，会发现前几个对矩阵的贡献很大，然后非常快速地下降：

这表明我们可以用相对少量的项来获得原始图像相当好的近似。我们可以通过对 U、S 和 Vt 矩阵进行切片并重新相乘来重建图像矩阵。我们还需要将 S 转换回 2D 矩阵以进行乘法。注意，我们使用 @ 运算符来执行矩阵乘法，因为 * 执行的是逐元素乘法。

这仍然相当模糊，所以让我们查看包含更多项的图像：

TODO: 打印上面使用的 n 值的压缩比。这是将 reduced 数组的字节数相加，然后除以原始灰度图像数组的大小。这与原始彩色 JPEG 的大小（756473 字节）相比如何？ 提示：.nbytes 对切片后的数组也有效！

TODO: 计算并显示 n = 10 时重建图像与原始图像之间的差异。显示差异图像时使用 cmap="coolwarm"。

